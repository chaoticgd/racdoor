#include <racdoor/exploit.h>

#include <racdoor/crypto.h>
#include <racdoor/mips.h>
#include <racdoor/util.h>

void arm(ExploitParams* params)
{
	/* Enable help text so that our exploit runs, but disable the help audio
	   since playing the same help message again and again would otherwise get
	   quite repetitive. */
	*params->help_voice_on = 0;
	*params->help_text_on = 1;
	
	/* TODO: More than 8 items must be unlocked for the help message we want to
	   use to be run. */
	
	/* Disable all the help messages except for the ones we want to use to
	   trigger the initial out of bounds write. */
	
	for (u32 i = 0; i < params->help_data_messages_count; i++)
	{
		HelpDatum* message = &params->help_data_messages[i];
		message->flag = (i == params->enabled_help_message) ? 0 : -1;
		message->unknown_2 = 0;
		message->unknown_4 = 0;
	}
	
	for (u32 i = 0; i < params->help_data_gadgets_count; i++)
	{
		HelpDatum* message = &params->help_data_gadgets[i];
		message->flag = (i == params->enabled_help_gadget) ? 0 : -1;
		message->unknown_2 = 0;
		message->unknown_4 = 0;
	}
	
	for (u32 i = 0; i < params->help_data_misc_count; i++)
	{
		HelpDatum* message = &params->help_data_misc[i];
		message->flag = -1;
		message->unknown_2 = 0;
		message->unknown_4 = 0;
	}
	
	/* Adjust the HelpLogPos variable so that the help message index is written
	   over the high byte of the jump target field from a relative branch
	   instruction such as to make the processor jump into and start executing
	   code loaded from the memory card. */
	*params->help_log_pos = (params->initial_hook + 1) - params->help_log;
	
	/* Because we cannot choose exactly where in the memory card data the
	   processor will jump to, we setup a trampoline to jump to a more desirable
	   location. */
	params->trampoline[0] = MIPS_J(params->trampoline_target);
	params->trampoline[1] = MIPS_NOP();
}

#ifdef _EE

extern u32 _racdoor_initial_hook;
extern void _racdoor_original_instruction;
extern u32 _racdoor_decryptor;
extern u32 _racdoor_payload;
extern u32 _racdoor_payload_end;
extern int HelpLogPos;

extern u32 payload_key;
extern u32 payload_entry;

void FlushCache(int mode);

void disarm(int encrypt)
{
	/* Restore the instruction that was modified. */
	_racdoor_initial_hook = (u32) &_racdoor_original_instruction;
	
	/* Flush the instruction cache. */
	FlushCache(2);
	
	/* Prevent any further instructions from being modified. */
	HelpLogPos = 0;
	
	/* Re-encrypt the payload to prepare it for being written back to the save
	   file on the memory card. */
	if (encrypt)
		xor_crypt(&_racdoor_payload, &_racdoor_payload_end, payload_key);
	
	/* Record the payload entry point address so we can rearm later. */
	payload_entry = (u32) MIPS_GET_TARGET(*(&_racdoor_decryptor + DECRYPTOR_JUMP_OFFSET));
}

#endif
