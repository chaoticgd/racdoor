/* This file is part of Racdoor.
   Copyright (c) 2024 chaoticgd. All rights reversed.
   Released under the BSD-1-Clause license. */

#include <racdoor/exploit.h>

#include <game/gameglobals.h>

#include <racdoor/crypto.h>
#include <racdoor/mips.h>
#include <racdoor/util.h>

#include <string.h>

void arm(ExploitParams* params)
{
	/* Enable help text so that our exploit runs.  */
	*params->help_voice_on = 0;
	*params->help_text_on = 1;
	
	/* TODO: More than 8 items must be unlocked for the help message we want to
	   use to be run. */
	
	/* Disable all the help messages except for the ones we want to use to
	   trigger the initial out of bounds write. */
	
	for (u32 i = 0; i < params->help_data_messages_count; i++)
	{
		HelpDatum* message = &params->help_data_messages[i];
		message->flag = (i == params->enabled_help_message) ? 0 : -1;
		message->unknown_2 = 0;
		message->unknown_4 = 0;
	}
	
	for (u32 i = 0; i < params->help_data_gadgets_count; i++)
	{
		HelpDatum* message = &params->help_data_gadgets[i];
		message->flag = (i == params->enabled_help_gadget) ? 0 : -1;
		message->unknown_2 = 0;
		message->unknown_4 = 0;
	}
	
	for (u32 i = 0; i < params->help_data_misc_count; i++)
	{
		HelpDatum* message = &params->help_data_misc[i];
		message->flag = -1;
		message->unknown_2 = 0;
		message->unknown_4 = 0;
	}
	
	/* Adjust the HelpLogPos variable so that the help message index is written
	   over the high byte of the jump target field from a relative branch
	   instruction such as to make the processor jump into and start executing
	   code loaded from the memory card. */
	*params->help_log_pos = (params->initial_hook + 1) - params->help_log;
	
	/* Because we cannot choose exactly where in the memory card data the
	   processor will jump to, we setup a trampoline to jump to a more desirable
	   location. */
	params->trampoline[0] = MIPS_J(params->trampoline_target);
	params->trampoline[1] = MIPS_NOP();
}

#ifdef _EE

extern u32 _racdoor_initial_hook;
extern void _racdoor_original_instruction;
extern u32 _racdoor_decryptor;
extern u32 _racdoor_payload;
extern u32 _racdoor_payload_end;

extern u32 decryptor[DECRYPTOR_SIZE];

void FlushCache(int mode);

void disarm(int encrypt)
{
	/* Restore the instruction that was modified. */
	_racdoor_initial_hook = (u32) &_racdoor_original_instruction;
	
	/* Flush the instruction cache. */
	FlushCache(2);
	
	/* Prevent any further instructions from being modified. */
	HelpLogPos = 0;
	
	/* Stash away a copy of the decryptor so it can be installed again later. */
	memcpy(decryptor, &_racdoor_decryptor, DECRYPTOR_SIZE * 4);
	
	/* Normalise the behaviour of the game system also using the memory. */
	memset(&_racdoor_decryptor, 0, DECRYPTOR_SIZE * 4);
	
	u32 payload_key = extract_key(decryptor);
	
	/* Re-encrypt the payload to prepare it for being written back to the save
	   file on the memory card. */
	if (encrypt)
		xor_crypt(&_racdoor_payload, &_racdoor_payload_end, payload_key);
	
	/* Disable the help system to prevent the message needed by the exploit
	   from playing. */
	HelpVoiceOn = 0;
	HelpTextOn = 0;
}

#endif
