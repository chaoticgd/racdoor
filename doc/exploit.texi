@node Exploits & Gadgets Not Fit For This World
@chapter Exploits & Gadgets Not Fit For This World

@node Save System
@section Save System

The games store the following files on the memory card:

@table @code

@item B<REGION><SERIAL>RATCHET
A memory dump starting from the location of the @code{Level} variable in memory.

It is not read back.

@item icon.sys, static.ico
Icon information to display in the browser.

@item save0.bin, save1.bin, save2.bin, save3.bin, save4.bin
A save slot.

@item net.bin
Multiplayer profiles and related information. Only present for Ratchet & Clank:
Up Your Arsenal and Ratchet: Deadlocked.

@item patch.bin
Executable patch file, designed to store updates downloaded from the network.

We do not take advantage of this for delivering the exploit since it is only
present in Ratchet: Deadlocked and is not specific to a certain save slot.

Additionally, it would clearly be cheating.

@end table

We are mainly interested in the @code{save<N>.bin} files. They are divided into
a section for data shared between all the levels, and sections for data specific
to each of the levels.

Each section consists of a checksum followed by a sequence of blocks. Each 
block contains a buffer of data and an ID number that determines the meaning of 
the data. The games contain arrays associating global variables that are to be
stored on the memory card with an ID number.

The level-specific sections are supposed to share a common structure. When they
are loaded from the memory card, the data associated with a given block number
is stored together in an array in memory, despite being stored separately in
the save file.

A random assortment of save game blocks are shown below:

@table @code

@item 16 HelpDataMessages
Help message information.

@item 17 HelpDataGadgets
Gadget-related help message information.

@item 18 HelpDataMisc
Miscellaneous help message information.

@item 1010 HelpLog
ID values of help messages that have already been shown to the player.

@item 1011 HelpLogPos
The number of ID values stored in the @code{HelpLog} array.

@end table

@node Map System
@section Map System

The first 3 games (Ratchet & Clank, Ratchet & Clank: Going Commando and Ratchet
& Clank: Up Your Arsenal) all contain a map screen that displays which areas
the player has explored.

This occupancy mask is stored on the memory card and takes 1024 bytes of storage
per level for a single save slot. Additionally, the mask is decompressed before
being used by the game, so the compressed version is only modified when a new
save file is being prepared.

The decompressor appears to be resilient to malformed input.

@node Help System
@section Help System

All 4 games contains a help system that displays messages to the player in the
form of audio and dialog boxes.

A list of the help messages that have been shown to player is recorded in the
@code{HelpLog} array which is stored on the memory card. The @code{HelpLogPos}
variable is used to store the number of help messages that have already been
written to this list and is also stored on the memory card.

The @code{Help_AddToLog} function is used to append a help message ID to the
end of the @code{HelpLog} array. The @code{HelpLogPos} variable is used to
determine at what index this message ID should be written, and the logic does
not verify that the index is within the bounds of the array.

Hence it is possible to use the @code{Help_AddToLog} function to overwrite data
at unrelated memory addresses with message ID values with some control.

One limitation of this approach is that if the @code{HelpLogPos} variable is
greater than the size of the array, logic in the @code{Help_AddToLog} function
that executes before the useful out of bounds write will trash memory which will
probably result in a crash.

In the case of Ratchet & Clank: Up Your Arsenal and Ratchet: Deadlocked, it is
possible to work around this limitation since the message ID is two bytes in 
size. The value of @code{HelpLogPos} is shifted left to convert the array index
to a memory offset, and hence we can always set the sign bit without affecting
the address that gets written to.

In the case of Ratchet & Clank and Ratchet & Clank: Going Commando, it is not
possible to work around this limitation on real hardware since the message ID
values are only 1 byte in size.

Under PCSX2, kernel memory mappings are exposed to user programs, including
mirrors of main memory. It is hence possible to use these mirrors to write to
any location in main memory while maintaining a negative value for the
@code{HelpLogPos} variable (we do not rely on this technique).

@node Putting It All Together
@section Putting It All Together

This section currently only applies to Ratchet & Clank, however similar exploits
should be achievable for Ratchet & Clank: Going Commando, Ratchet & Clank: Up
Your Arsenal and Ratchet: Deadlocked too.

Once Ratchet has more than 8 weapons and gadgets unlocked, the game will display
a help message informing the player that they can reconfigure the contents of
the quick select menu from the pause menu. The game sets a flag to make sure
that this message is only displayed once. In the case of R&C1, this help
message has an ID value of 0x50.

It is possible to ensure that this help message, and only this help message, is
displayed to the player immediately after loading a save game and transitioning
to the new level. This is done by making sure the help system is enabled, and
by setting the appropriate flags to enable the help message we want to be
displayed and disabling all the rest.

By setting the @code{HelpLogPos} variable appropriately, it is possible to
overwrite the most significant byte of the target field of a relative branch
instruction with the ID value of the displayed help message.

The Ghidra script @code{FindMemcardBranches.java}, which is included in the
Racdoor repository in the @code{scripts} directory, can be used to find relative
branch instructions that when overwritten with a given help message ID and
executed will cause the processor to jump into a data block loaded from the
memory card.

In the case of the original Ratchet & Clank game, the third party library
function @code{snd_FlushSoundCommands}, as well as a number of other functions,
happen to be at the right location in memory such that this can occur. In
addition, @code{snd_FlushSoundCommands} runs every frame.

Since the destination of the modified branch instruction is somewhat hard to
control, the instruction we write at that address is an unconditional jump
that functions as a trampoline to jump to further bootstrap code.

This bootstrap code decrypts the main payload, which is stored in the save game
block for the map mask, and jumps into the loader. The loader backs up the
values of all the general purpose registers onto the stack, loads the payload
by copying, filling and decompressing each section as required, calls the next
stage, restores the values of the general purpose registers, and then jumps
back to the game like nothing ever happened.
