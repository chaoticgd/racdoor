// Imports all the level overlays from one of the Ratchet & Clank PS2 games.
//
// Instructions:
//  1. Unpack the game using wrench (0.4 or newer, or the latest unstable build).
//  2. Import the boot ELF, but don't run auto analysis.
//  3. Run the script, select the directory containing the newly unpacked asset
//     bank e.g. rac_sces_509_16.
//  4. Run auto analysis.
//@author chaoticgd
//@category Ratchet & Clank
//@keybinding 
//@menupath 
//@toolbar 

import java.io.File;
import java.util.ArrayList;

import ghidra.app.script.GhidraScript;
import ghidra.app.util.MemoryBlockUtils;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.format.elf.ElfHeader;
import ghidra.app.util.bin.format.elf.ElfProgramHeader;
import ghidra.app.util.bin.format.elf.ElfSectionHeader;
import ghidra.formats.gfilesystem.FSRL;
import ghidra.formats.gfilesystem.FileSystemService;
import ghidra.program.database.mem.FileBytes;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeConflictHandler;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.ParameterImpl;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.symbol.SourceType;

public class ImportLevelOverlays extends GhidraScript {
	public void run() throws Exception {
		// Prompt the user for an asset bank, as can be extracted by wrench.
		File assetBank = askDirectory("Choose Asset Bank Directory", "Select");
		
		// Iterate over each of the levels.
		File levels = new File(assetBank.getPath() + "/levels");
		for(File level : levels.listFiles()) {
			if(level.isDirectory()) {
				boolean success = importLevelOverlay(level);
				if(!success) {
					// It wasn't a level, it was a folder containing multiple levels.
					for(File actualLevel : level.listFiles()) {
						if(actualLevel.isDirectory()) {
							importLevelOverlay(actualLevel);
						}
					}
				}
			}
		}
	}
	
	public boolean importLevelOverlay(File level) throws Exception {
		Memory memory = currentProgram.getMemory();
		FileSystemService fileSystemService = FileSystemService.getInstance();
		
		File overlayFile = new File(level.getPath() + "/overlay.elf");
		if(!overlayFile.exists()) {
			return false;
		}
		FSRL overlayFSRL = fileSystemService.getLocalFSRL(overlayFile);
		ByteProvider provider = null;
		try {
			// Open the overlay file.
			provider = fileSystemService.getByteProvider(overlayFSRL, false, getMonitor());
			FileBytes fileBytes = MemoryBlockUtils.createFileBytes(currentProgram, provider, monitor);
			
			// Parse the ELF file.
			ElfHeader elfHeaders = new ElfHeader(provider, null);
			elfHeaders.parse();
			
			// Create the memory block. Include only the first segment (this
			// excludes Deadlock's patch data segment). These program
			// headers are generated by wrench since Insomniac's loader
			// works with sections instead of segments.
			ElfProgramHeader segment = elfHeaders.getProgramHeaders()[0];
			MemoryBlock block = memory.createInitializedBlock(
					"lvl" + level.getName(),
					toAddr(segment.getVirtualAddress()),
					fileBytes,
					segment.getOffset(),
					segment.getMemorySize(),
					true);
			block.setExecute(true);
			
			// Create labels for each of the sections.
			AddressSpace overlaySpace = block.getStart().getAddressSpace();
			for(ElfSectionHeader section : elfHeaders.getSections()) {
				if(section.getAddress() > 0) {
					String label = "lvl" + level.getName() + "_" + section.getNameAsString();
					createLabel(overlaySpace.getAddress(section.getAddress()), label, false);
				}
			}
			
			// Find the update function tables.
			ElfSectionHeader mobyTable = null;
			ElfSectionHeader cameraTable = null;
			ElfSectionHeader soundTable = null;
			for(ElfSectionHeader section : elfHeaders.getSections()) {
				if(section.getNameAsString().equals("lvl.vtbl")) {
					mobyTable = section;
				}
				if(section.getNameAsString().equals("lvl.camvtbl")) {
					cameraTable = section;
				}
				if(section.getNameAsString().equals("lvl.sndvtbl")) {
					soundTable = section;
				}
			}
			
			// Create the update functions.
			if(mobyTable != null) {
				createMobyFunctions(level.getName(),
						overlaySpace.getAddress(mobyTable.getAddress()),
						overlaySpace.getAddress(mobyTable.getAddress() + mobyTable.getSize()));
			}
			if(cameraTable != null) {
				createCameraFunctions(level.getName(),
						overlaySpace.getAddress(cameraTable.getAddress()),
						overlaySpace.getAddress(cameraTable.getAddress() + cameraTable.getSize()));
			}
			if(soundTable != null) {
				createSoundFunctions(level.getName(),
						overlaySpace.getAddress(soundTable.getAddress()),
						overlaySpace.getAddress(soundTable.getAddress() + soundTable.getSize()));
			}
		} finally {
			if(provider != null) {
				provider.close();
			}
		}
		return true;
	}
	
	public void createMobyFunctions(String level, Address start, Address end) throws Exception {
		DataType mobyInstance = new StructureDataType("MobyInstance", 0x100);
		mobyInstance = currentProgram.getDataTypeManager().addDataType(mobyInstance, DataTypeConflictHandler.DEFAULT_HANDLER);
		
		int size = (int) (end.getOffset() - start.getOffset());
		for(int i = 0; i < size; i += 12) {
			int classId = getInt(start.add(i));
			int functionPointer = getInt(start.add(i + 4));
			
			if(classId == -1) {
				break;
			}
			
			createOrRenameUpdateFunction(
					start.getAddressSpace(),
					"lvl" + level + "_UpdateMoby_",
					"pMoby",
					mobyInstance,
					classId,
					functionPointer,
					false);
		}
	}
	
	public void createCameraFunctions(String level, Address start, Address end) throws Exception {
		DataType cameraInstance = new StructureDataType("UpdateCam", 0xb0);
		cameraInstance = currentProgram.getDataTypeManager().addDataType(cameraInstance, DataTypeConflictHandler.DEFAULT_HANDLER);
		
		int size = (int) (end.getOffset() - start.getOffset());
		for(int i = 0; i < size; i += 20) {
			int classId = getInt(start.add(i));
			int functionPointer1 = getInt(start.add(i + 4));
			int functionPointer2 = getInt(start.add(i + 8));
			int functionPointer3 = getInt(start.add(i + 12));
			int functionPointer4 = getInt(start.add(i + 16));
			
			if(classId == -1) {
				break;
			}
			
			createOrRenameUpdateFunction(
					start.getAddressSpace(),
					"lvl" + level + "_InitCamera_",
					"pCam",
					cameraInstance,
					classId,
					functionPointer1,
					false);
			
			createOrRenameUpdateFunction(
					start.getAddressSpace(),
					"lvl" + level + "_ActivateCamera_",
					"pCam",
					cameraInstance,
					classId,
					functionPointer2,
					true);
			
			createOrRenameUpdateFunction(
					start.getAddressSpace(),
					"lvl" + level + "_UpdateCamera_",
					"pCam",
					cameraInstance,
					classId,
					functionPointer3,
					false);
			
			createOrRenameUpdateFunction(
					start.getAddressSpace(),
					"lvl" + level + "_ExitCamera_",
					"pCam",
					cameraInstance,
					classId,
					functionPointer4,
					false);
		}
	}

	public void createSoundFunctions(String level, Address start, Address end) throws Exception {
		DataType soundInstance = new StructureDataType("SoundInstance", 0x90);
		soundInstance = currentProgram.getDataTypeManager().addDataType(soundInstance, DataTypeConflictHandler.DEFAULT_HANDLER);
		
		int size = (int) (end.getOffset() - start.getOffset());
		for(int i = 0; i < size; i += 8) {
			int classId = getInt(start.add(i));
			int functionPointer = getInt(start.add(i + 4));
			
			if(classId == -1) {
				break;
			}
			
			createOrRenameUpdateFunction(
					start.getAddressSpace(),
					"lvl" + level + "_UpdateSound_",
					"pSound",
					soundInstance,
					classId,
					functionPointer,
					false);
		}
	}
	
	public void createOrRenameUpdateFunction(
			AddressSpace space,
			String namePrefix,
			String parameterName,
			DataType instanceType,
			int classId,
			int functionPointer,
			boolean isActivateCamFunction) throws Exception {
		if(functionPointer == 0) {
			return;
		}
		
		Address address = space.getAddress(functionPointer);
		Function function = this.getFunctionAt(address);
		if(function == null) {
			String name = namePrefix + Integer.toString(classId);
			function = createFunction(address, name);
			if(function == null) {
				println("Cannot create " + name + " at " + Integer.toString(functionPointer));
				return;
			}
			
			// Setup the parameter.
			ArrayList<Variable> parameters = new ArrayList<>();
			parameters.add(new ParameterImpl(parameterName, new PointerDataType(instanceType), currentProgram));
			if(isActivateCamFunction) {
				parameters.add(new ParameterImpl("pCompare", new PointerDataType(instanceType), currentProgram));
			}
			function.replaceParameters(parameters, Function.FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
		} else {
			function.setName(function.getName() + "_" + Integer.toString(classId), SourceType.IMPORTED);
		}
	}
}
